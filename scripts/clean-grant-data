#!/usr/bin/env node
'use strict';
const fs = require('fs');
const es = require('event-stream');
const moment = require('moment');
const { pickBy, identity, get, includes, uniq, flow } = require('lodash');
const split = require('split');

const wardLocations = require('../data/ward-locations');
const fundingProgrammes = require('../data/fundingProgrammes');
const knownProgrammes = Object.keys(fundingProgrammes);

const argv = require('yargs')
    .alias('f', 'file')
    .describe('f', 'The path to a JSON file to clean')
    .alias('o', 'output')
    .describe('b', 'The path to the JSON file to output')
    .help('h')
    .alias('h', 'help').argv;

const COUNTRIES = {
    england: {
        pattern: /^E/,
        title: 'England'
    },
    wales: {
        pattern: /^W/,
        title: 'Wales'
    },
    scotland: {
        pattern: /^S/,
        title: 'Scotland'
    },
    'northern-ireland': {
        pattern: /^N/,
        title: 'Northern Ireland'
    }
};

// Turn date fields into actual Date objects
const parseDates = data => {
    const dateFields = [
        'Award Date',
        'Planned Dates:Start Date',
        'Planned Dates:End Date',
        'Last modified'
    ];
    dateFields.forEach(dateField => {
        if (data[dateField]) {
            // We specify several parsing formats here because the source data uses different formats
            // eg. older data is 2004-04-16 and the rest uses 8/17/15
            const parsedDate = moment(data[dateField].trim(), ["MM/DD/YYYY", "YYYY-MM-DD"]);
            if (parsedDate.isValid()) {
                data[dateField] = {
                    $date: parsedDate.toDate()
                };
            }
        }
    });
    return data;
};

// Split organisation strings into proper structures
const separateOrgType = data => {
    const orgTypeKey = 'BIGField_Organisation_Type';
    if (data[orgTypeKey]) {
        const parts = data[orgTypeKey].split(' : ');
        data.organisationType = data[orgTypeKey];
        delete data[orgTypeKey];
        if (parts.length > 1) {
            data.organisationType = parts[0];
            data.organisationSubtype = parts[1];
        }
    }
    return data;
};

// Rename the fields to something more useful and drop unused fields
// http://standard.threesixtygiving.org/en/latest/_static/docson/index.html#../360-giving-schema.json
const rename = data => {

    const plannedDates = { startDate: data['Planned Dates:Start Date'] };

    if (data['Planned Dates:End Date']) {
        plannedDates.endDate = data['Planned Dates:End Date'];
    }

    const newData = {
        id: data['Identifier'],
        title: data['Title'],
        description: data['Description'],
        currency: data['Currency'],
        amountAwarded: parseFloat(data['Amount Awarded']),
        awardDate: data['Award Date'],
        plannedDates: [plannedDates],
        recipientOrganization: {
            id: data['Recipient Org:Identifier'],
            name: data['Recipient Org:Name'],
            charityNumber: data['Recipient Org:Charity Number'] || undefined,
            companyNumber: data['Recipient Org:Company Number'] || undefined,
            // @TODO https://github.com/OpenDataServices/grantnav/issues/490
            organisationType: data['organisationType'],
            organisationSubtype: data['organisationSubtype']
        },
        fundingOrganization: {
            id: data['Funding Org:Identifier'],
            name: data['Funding Org:Name']
        },
        grantProgramme: {
            code: data['Grant Programme:Code'],
            title: data['Grant Programme:Title']
        },
        dateModified: data['Last modified']
    };

    function getCountryName(geocode) {
        let countryName, isValid;
        for (let countryKey in COUNTRIES) {
            const country = COUNTRIES[countryKey];
            isValid = country.pattern.test(geocode);
            if (isValid) {
                countryName = country.title;
                break;
            }
        }
        return countryName;
    }

    // Some records have no location, so only add that field if we find one
    if (data['Recipient Org:Location:0:Name'] &&
        data['Recipient Org:Location:0:Name'] !== '' &&
        data['Recipient Org:Location:0:Name'] !== 'NULL'
    ) {
        // Add the first location (always a ward code)
        newData.beneficiaryLocation = [
            {
                name: data['Recipient Org:Location:0:Name'],
                geoCode: data['Recipient Org:Location:0:Geographic Code'],
                geoCodeType: 'WD'
            }
        ];

        // There's a slim possibility a record has one location, but not a second
        // So add the local authority if we have one
        if (data['Recipient Org:Location:1:Name'] && data['Recipient Org:Location:1:Name'] !== '') {
            const ladGeoCode = data['Recipient Org:Location:1:Geographic Code'];
            let localAuthorityData = {
                name: data['Recipient Org:Location:1:Name'],
                geoCode: ladGeoCode,
                geoCodeType: 'CMLAD'
            };
            // Add the country name (if valid) for later filtering
            const countryName = getCountryName(ladGeoCode);
            if (countryName) {
                localAuthorityData.country = countryName;
            }
            newData.beneficiaryLocation.push(localAuthorityData);
        }
    }

    // Strip out null / undefined
    return pickBy(newData, identity);

};

// Replace an egregious spelling error on 22k+ records
const fixHeroesReturnTypo = data => {
    const wrong = 'This is a programme for individual veterans as opposed to organisaitons';
    const right = 'This is a programme for individual veterans as opposed to organisations';
    if (data.recipientOrganization.name.indexOf(wrong) !== -1) {
        data.recipientOrganization.name = data.recipientOrganization.name.replace(wrong, right);
    }
    return data;
};

// Rename funding programmes from their FMS/internal name
// to a public-facing one
const programmesToRename = [
    {
        from: 'UK Accelerating Ideas',
        to: 'UK Portfolio'
    }
];
const renameProgrammes = data => {
    const shouldRename = programmesToRename.find(p => p.from === data.grantProgramme.title);
    if (shouldRename) {
        data.grantProgramme.titleInternal = data.grantProgramme.title;
        data.grantProgramme.title = shouldRename.to;
    }
    return data;
};

// Replace some wrongly-encoded characters (mostly quotes) with the correct symbols
const fixEncodingIssues = data => {
    // eg [pattern, replacement]
    const encodingFixes = [
        [/â€™/g, "'"],
        [/â€˜/g, "'"],
        [/â€™/g, "'"],
        [/â€“/g, "–"],
        [/â€¦/g, "…"],
        [/â€œ/g, '"'],
        [/Â£/g, '£'],
        [/â€/g, '"'], // must come last, otherwise too general
    ];
    encodingFixes.forEach(pair => {
        let [wrong, right] = pair;
        if (data.title) {
            const hasBrokenTitle = data.title.match(wrong);
            if (hasBrokenTitle) {
                data.title = data.title.replace(wrong, right);
            }
        }
        if (data.description) {
            const hasBrokenDescription = data.description.match(wrong);
            if (hasBrokenDescription) {
                data.description = data.description.replace(wrong, right);
            }
        }
    });

    return data;
};

const addLocations = data => {
    // Find the first location (eg. ward)
    const wardCode = (data.beneficiaryLocation && data.beneficiaryLocation[0].geoCode) || false;
    const match = wardLocations.find(m => m.wardCode === wardCode);

    if (match) {
        // Add the constituency location
        data.beneficiaryLocation.push({
            name: match.constituencyName,
            geoCode: match.constituencyCode,
            geoCodeType: 'WPC'
        });

        // If we have lat/lngs for this ward, add them too
        if (match.location) {
            data.beneficiaryLocation[0].location = {
                type: "Point",
                coordinates: [
                    parseFloat(match.location.long),
                    parseFloat(match.location.lat)
                ]
            }
        }
    }

    return data;
};

// Check to see if we need to add a new programme mapping
const unknownProgrammes = [];
const checkForNewProgrammes = data => {
    if (data.grantProgramme && knownProgrammes.indexOf(data.grantProgramme.code) === -1) {
        unknownProgrammes.push(data.grantProgramme.code);
    }
    return data;
};


const outputFileStream = fs.createWriteStream(argv.o, { flags:'a' });

const getStream = function () {
    const stream = fs.createReadStream(argv.f, {encoding: 'utf8'});
    return stream.pipe(split(JSON.parse, null, { trailing: false }));
};

console.log('Beginning cleaning of grant data...');

getStream().pipe(es.mapSync((data) => {
    let cleaned = flow(
        parseDates,
        separateOrgType,
        rename,
        fixHeroesReturnTypo,
        fixEncodingIssues,
        addLocations,
        renameProgrammes,
        checkForNewProgrammes
    )(data);

    // Remove data from internal-only programmes
    // (eg. transfer of funds)
    const invalidProgrammeCodes = ['PFP1'];
    const mainProgrammeCode = get(cleaned, 'grantProgramme.code');
    if (!includes(invalidProgrammeCodes, mainProgrammeCode)) {
        outputFileStream.write(JSON.stringify(cleaned) + '\n');
    } else {
        console.log('Skipped output', cleaned);
    }

}).on('error', function (err) {
    console.log('Error parsing JSON', err);
}).on('end', () => {
    console.log('Finished cleaning JSON - file written successfully.');
    if (unknownProgrammes.length > 0) {
        console.log('=================');
        console.log('Some unknown programmes were included in this import.');
        console.log('You should add the following items to /data/fundingProgrammes.js');
        uniq(unknownProgrammes).forEach(programme => {
            let data = {};
            data[programme] = {
                "_id": programme,
                "urlPath": "/relative/url/goes/here"
            };
            console.log(JSON.stringify(data, null, 4));
        });
    }
    outputFileStream.end();
}));
